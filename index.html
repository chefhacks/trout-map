<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bulgaria Fishing Weather Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    #map { width: 100%; height: 100vh; }

    /* --- Toggle button --- */
    .panel-toggle {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1002;
      width: 40px;
      height: 40px;
      border: none;
      border-radius: 8px;
      background: white;
      box-shadow: 0 2px 10px rgba(0,0,0,0.25);
      font-size: 20px;
      line-height: 40px;
      text-align: center;
      cursor: pointer;
      transition: background 0.15s;
      -webkit-tap-highlight-color: transparent;
    }
    .panel-toggle:hover { background: #f0f0f0; }
    .panel-toggle:active { background: #e0e0e0; }

    /* --- Side panel --- */
    .side-panel {
      position: absolute;
      top: 0; right: 0;
      z-index: 1001;
      width: 260px;
      max-width: 85vw;
      height: 100%;
      background: white;
      box-shadow: -2px 0 12px rgba(0,0,0,0.2);
      overflow-y: auto;
      overflow-x: hidden;
      transform: translateX(100%);
      transition: transform 0.25s ease;
      -webkit-overflow-scrolling: touch;
    }
    .side-panel.open { transform: translateX(0); }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 14px 8px;
      border-bottom: 1px solid #eee;
      position: sticky;
      top: 0;
      background: white;
      z-index: 1;
    }
    .panel-header h2 { font-size: 15px; font-weight: 700; }
    .panel-close {
      width: 32px; height: 32px;
      border: none; border-radius: 6px;
      background: transparent;
      font-size: 20px; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      -webkit-tap-highlight-color: transparent;
    }
    .panel-close:hover { background: #f0f0f0; }

    .panel-body { padding: 10px 14px 20px; font-size: 13px; }

    .panel-section {
      margin-bottom: 14px;
      padding-bottom: 10px;
      border-bottom: 1px solid #eee;
    }
    .panel-section:last-child { border-bottom: none; margin-bottom: 0; }
    .panel-section-title {
      font-weight: 700;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #555;
      margin-bottom: 8px;
    }

    .panel-body label {
      display: block;
      margin-bottom: 3px;
      font-weight: 600;
      font-size: 12px;
    }
    .panel-body select, .panel-body input[type=range] {
      width: 100%;
      padding: 5px 6px;
      margin-bottom: 8px;
      border-radius: 4px;
      border: 1px solid #ccc;
      font-size: 13px;
    }
    .panel-body .btn {
      width: 100%;
      padding: 8px;
      border: none;
      border-radius: 6px;
      background: #2563eb;
      color: white;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
      -webkit-tap-highlight-color: transparent;
    }
    .panel-body .btn:hover { background: #1d4ed8; }
    .panel-body .btn:active { background: #1e40af; }

    .legend-row { display: flex; align-items: center; margin: 2px 0; font-size: 12px; }
    .legend-color {
      width: 20px; height: 14px; margin-right: 6px;
      border-radius: 2px; border: 1px solid rgba(0,0,0,0.1);
      flex-shrink: 0;
    }

    /* --- Status bar --- */
    .status {
      position: absolute;
      bottom: 8px;
      left: 8px;
      right: 8px;
      z-index: 1000;
      background: rgba(255,255,255,0.92);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
      border-radius: 8px;
      padding: 6px 10px;
      box-shadow: 0 1px 6px rgba(0,0,0,0.15);
      font-size: 11px;
      text-align: center;
      pointer-events: none;
    }

    /* --- Tile text labels --- */
    .tile-label {
      font-family: 'SF Mono', 'Consolas', 'Monaco', monospace;
      line-height: 1.2;
      white-space: nowrap;
      pointer-events: none;
      text-shadow: 0 0 3px rgba(255,255,255,0.9), 0 0 6px rgba(255,255,255,0.7);
    }
    .tile-label .wind-arrow {
      display: inline-block;
      font-size: 1.3em;
      vertical-align: middle;
      line-height: 1;
    }
    .tile-label .fish-score { font-weight: 700; }
    .fish-score-good { color: #16a34a; }
    .fish-score-ok { color: #ca8a04; }
    .fish-score-poor { color: #dc2626; }

    /* Dim overlay behind panel on mobile */
    .panel-backdrop {
      display: none;
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      z-index: 1000;
      background: rgba(0,0,0,0.3);
    }
    .panel-backdrop.visible { display: block; }
  </style>
</head>
<body>
  <div id="map"></div>

  <button class="panel-toggle" id="panelToggle" aria-label="Open settings">&#9776;</button>
  <div class="panel-backdrop" id="panelBackdrop"></div>

  <div class="side-panel" id="sidePanel">
    <div class="panel-header">
      <h2>Fishing Weather</h2>
      <button class="panel-close" id="panelClose" aria-label="Close">&times;</button>
    </div>
    <div class="panel-body">

      <div class="panel-section">
        <div class="panel-section-title">Controls</div>
        <label for="colorBy">Color tiles by</label>
        <select id="colorBy">
          <option value="temperature_2m">Temperature</option>
          <option value="surface_pressure">Pressure</option>
          <option value="wind_speed_10m">Wind Speed</option>
          <option value="precipitation">Precipitation</option>
          <option value="cloud_cover">Cloud Cover</option>
        </select>
        <label for="opacity">Overlay opacity</label>
        <input type="range" id="opacity" min="0.05" max="0.85" step="0.05" value="0.35">
        <label for="fontSize">Label size</label>
        <input type="range" id="fontSize" min="7" max="14" step="1" value="10">
        <button class="btn" id="refresh">Refresh (bypass cache)</button>
      </div>

      <div class="panel-section" id="legendScale"></div>

      <div class="panel-section">
        <div class="panel-section-title">Tile Labels</div>
        <div style="font-size:11px;line-height:1.5">
          <b>Score</b> = fishing score (0-100)<br>
          <b>Arrow</b> = wind direction<br>
          <b>Number after arrow</b> = wind km/h<br>
          <b>&deg;</b> = temperature &deg;C<br>
          <b>hPa</b> = atm. pressure<br>
          <b>mm</b> = precipitation<br>
          <b>&#9729;</b> = cloud cover %
        </div>
      </div>

      <div class="panel-section">
        <div class="panel-section-title">Fishing Score Guide</div>
        <div style="font-size:11px;line-height:1.5">
          <span class="fish-score-good"><b>65+</b> Great</span><br>
          <span class="fish-score-ok"><b>40-64</b> Fair</span><br>
          <span class="fish-score-poor"><b>&lt;40</b> Poor</span><br>
          <br>Best: 1010-1020 hPa,<br>wind &lt;15 km/h,<br>overcast, light rain,<br>12-20&deg;C
        </div>
      </div>

    </div>
  </div>

  <div class="status" id="status">Zoom or pan to load weather data</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // --- Config ---
    const BULGARIA_CENTER = [42.6977, 23.3219]; // Sofia
    const INITIAL_ZOOM = 8;
    const API_BASE = 'https://api.open-meteo.com/v1/forecast';
    const MAX_POINTS_PER_REQUEST = 150;
    const CACHE_TTL_MS = 30 * 60 * 1000;
    const CACHE_MAX_ENTRIES = 3000;
    const BATCH_DELAY_MS = 350;
    const MAX_RETRIES = 3;

    // All variables fetched in a SINGLE request per point
    const HOURLY_VARS = [
      'temperature_2m',
      'wind_speed_10m',
      'wind_direction_10m',
      'surface_pressure',
      'precipitation',
      'cloud_cover',
    ].join(',');

    // --- Color scales ---
    const COLOR_SCALES = {
      temperature_2m: {
        unit: '°C', label: 'Temperature',
        stops: [
          { val: -10, color: [49, 54, 149] },
          { val: 0,   color: [69, 117, 180] },
          { val: 10,  color: [171, 217, 233] },
          { val: 20,  color: [255, 255, 191] },
          { val: 30,  color: [253, 174, 97] },
          { val: 40,  color: [215, 48, 39] },
        ]
      },
      surface_pressure: {
        unit: 'hPa', label: 'Pressure',
        stops: [
          { val: 990,  color: [49, 54, 149] },
          { val: 1000, color: [116, 173, 209] },
          { val: 1010, color: [171, 217, 233] },
          { val: 1015, color: [255, 255, 191] },
          { val: 1020, color: [254, 224, 144] },
          { val: 1030, color: [253, 174, 97] },
          { val: 1040, color: [215, 48, 39] },
        ]
      },
      wind_speed_10m: {
        unit: 'km/h', label: 'Wind Speed',
        stops: [
          { val: 0,  color: [224, 243, 248] },
          { val: 10, color: [171, 217, 233] },
          { val: 20, color: [100, 180, 255] },
          { val: 35, color: [30, 100, 200] },
          { val: 50, color: [200, 80, 80] },
          { val: 80, color: [150, 0, 0] },
        ]
      },
      precipitation: {
        unit: 'mm', label: 'Precipitation',
        stops: [
          { val: 0,   color: [255, 255, 240] },
          { val: 0.5, color: [200, 230, 255] },
          { val: 2,   color: [100, 180, 255] },
          { val: 5,   color: [30, 100, 220] },
          { val: 15,  color: [20, 50, 150] },
          { val: 30,  color: [100, 0, 150] },
        ]
      },
      cloud_cover: {
        unit: '%', label: 'Cloud Cover',
        stops: [
          { val: 0,   color: [255, 255, 220] },
          { val: 25,  color: [230, 230, 210] },
          { val: 50,  color: [190, 190, 190] },
          { val: 75,  color: [140, 140, 150] },
          { val: 100, color: [90, 90, 110] },
        ]
      },
    };

    // --- Fishing score ---
    // Factors: pressure trend matters most but we only have current snapshot,
    // so we score based on: pressure stability (mid-range = best), low wind,
    // overcast skies, light or no rain, moderate temps.
    function computeFishScore(d) {
      let score = 0;

      // Pressure: 1010-1020 hPa is ideal, slightly falling is best
      // We approximate: mid-range pressure scores highest
      const p = d.surface_pressure;
      if (p >= 1008 && p <= 1022) score += 30;
      else if (p >= 1000 && p <= 1030) score += 20;
      else score += 5;

      // Wind: calm to light is best for fishing (0-15 km/h)
      const w = d.wind_speed_10m;
      if (w <= 8) score += 25;
      else if (w <= 15) score += 20;
      else if (w <= 25) score += 10;
      else score += 0;

      // Cloud cover: overcast/cloudy is generally better (fish less spooked)
      const cc = d.cloud_cover;
      if (cc >= 50 && cc <= 90) score += 20;
      else if (cc >= 30) score += 15;
      else score += 8;

      // Precipitation: light rain can be great, heavy rain is bad
      const pr = d.precipitation;
      if (pr > 0 && pr <= 2) score += 15;   // light rain/drizzle = excellent
      else if (pr === 0) score += 10;
      else if (pr <= 5) score += 8;
      else score += 0;                       // heavy rain

      // Temperature: fish are most active 10-22°C (trout especially)
      const t = d.temperature_2m;
      if (t >= 12 && t <= 20) score += 10;
      else if (t >= 8 && t <= 25) score += 7;
      else if (t >= 4 && t <= 30) score += 3;
      else score += 0;

      return Math.min(100, Math.max(0, score));
    }

    // --- Wind direction helpers ---
    function windDirToArrow(deg) {
      // Arrows point in the direction wind is blowing TO
      // (meteorological convention: 0° = from N, so arrow points S → ↓)
      const arrows = ['↓','↙','←','↖','↑','↗','→','↘'];
      const idx = Math.round(deg / 45) % 8;
      return arrows[idx];
    }

    function windDirToCompass(deg) {
      const dirs = ['N','NE','E','SE','S','SW','W','NW'];
      return dirs[Math.round(deg / 45) % 8];
    }

    // --- Cache ---
    // Key: "lat|lon" -> { data: {temp, wind, windDir, pressure, precip, cloud}, timestamp }
    const cache = new Map();

    function cacheKey(lat, lon) { return `${lat}|${lon}`; }

    function cacheGet(lat, lon) {
      const entry = cache.get(cacheKey(lat, lon));
      if (!entry) return undefined;
      if (Date.now() - entry.timestamp > CACHE_TTL_MS) {
        cache.delete(cacheKey(lat, lon));
        return undefined;
      }
      return entry.data;
    }

    function cachePut(lat, lon, data) {
      if (cache.size >= CACHE_MAX_ENTRIES) {
        // Evict oldest
        let oldestKey = null, oldestTs = Infinity;
        for (const [k, v] of cache) {
          if (v.timestamp < oldestTs) { oldestTs = v.timestamp; oldestKey = k; }
        }
        if (oldestKey) cache.delete(oldestKey);
      }
      cache.set(cacheKey(lat, lon), { data, timestamp: Date.now() });
    }

    function cacheValidCount() {
      let n = 0;
      const now = Date.now();
      for (const v of cache.values()) {
        if (now - v.timestamp <= CACHE_TTL_MS) n++;
      }
      return n;
    }

    // --- Color interpolation ---
    function getColor(value, stops) {
      if (value <= stops[0].val) return stops[0].color;
      if (value >= stops[stops.length - 1].val) return stops[stops.length - 1].color;
      for (let i = 0; i < stops.length - 1; i++) {
        if (value >= stops[i].val && value <= stops[i + 1].val) {
          const t = (value - stops[i].val) / (stops[i + 1].val - stops[i].val);
          return [
            Math.round(stops[i].color[0] + t * (stops[i + 1].color[0] - stops[i].color[0])),
            Math.round(stops[i].color[1] + t * (stops[i + 1].color[1] - stops[i].color[1])),
            Math.round(stops[i].color[2] + t * (stops[i + 1].color[2] - stops[i].color[2])),
          ];
        }
      }
      return stops[stops.length - 1].color;
    }

    function rgbStr(c, a) { return `rgba(${c[0]},${c[1]},${c[2]},${a})`; }

    // --- Map setup ---
    const map = L.map('map', {
      center: BULGARIA_CENTER,
      zoom: INITIAL_ZOOM,
      minZoom: 6,
      maxZoom: 13,
    });

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OSM</a> | <a href="https://open-meteo.com/">Open-Meteo</a>',
      maxZoom: 19,
    }).addTo(map);

    // --- State ---
    let rectLayer = L.layerGroup().addTo(map);
    let labelLayer = L.layerGroup().addTo(map);
    let currentAbort = null;
    let debounceTimer = null;
    let lastRenderData = null; // { points: [...], step }

    // --- Grid ---
    function getGridStep(zoom) {
      if (zoom >= 12) return 0.03;
      if (zoom >= 11) return 0.06;
      if (zoom >= 10) return 0.1;
      if (zoom >= 9)  return 0.15;
      if (zoom >= 8)  return 0.2;
      if (zoom >= 7)  return 0.35;
      return 0.5;
    }

    function buildGrid(bounds, step) {
      const points = [];
      const south = Math.floor(bounds.getSouth() / step) * step;
      const north = Math.ceil(bounds.getNorth() / step) * step;
      const west = Math.floor(bounds.getWest() / step) * step;
      const east = Math.ceil(bounds.getEast() / step) * step;
      for (let lat = south; lat <= north; lat += step) {
        for (let lon = west; lon <= east; lon += step) {
          points.push({ lat: Math.round(lat * 1000) / 1000, lon: Math.round(lon * 1000) / 1000 });
        }
      }
      return points;
    }

    function getCurrentHourIndex(times) {
      const now = new Date();
      let bestIdx = 0, bestDiff = Infinity;
      for (let i = 0; i < times.length; i++) {
        const diff = Math.abs(new Date(times[i]).getTime() - now.getTime());
        if (diff < bestDiff) { bestDiff = diff; bestIdx = i; }
      }
      return bestIdx;
    }

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    // --- API ---
    async function fetchWithRetry(url, signal) {
      for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
        const resp = await fetch(url, { signal });
        if (resp.ok) return resp;
        if (resp.status === 429 && attempt < MAX_RETRIES) {
          const ra = resp.headers.get('Retry-After');
          const wait = ra ? parseInt(ra, 10) * 1000 : Math.min(2000 * Math.pow(2, attempt), 16000);
          console.warn(`429 → retry in ${wait}ms (${attempt + 1}/${MAX_RETRIES})`);
          await sleep(wait);
          continue;
        }
        throw new Error(`API error: ${resp.status}`);
      }
      throw new Error('Max retries exceeded (429)');
    }

    // Fetch ALL fishing variables for a batch of points in ONE request
    async function fetchBatch(points, signal) {
      const lats = points.map(p => p.lat).join(',');
      const lons = points.map(p => p.lon).join(',');
      const url = `${API_BASE}?latitude=${lats}&longitude=${lons}&hourly=${HOURLY_VARS}&forecast_days=1&timezone=auto`;

      const resp = await fetchWithRetry(url, signal);
      const raw = await resp.json();
      const results = Array.isArray(raw) ? raw : [raw];

      return results.map((r, i) => {
        const hi = getCurrentHourIndex(r.hourly.time);
        const data = {
          temperature_2m:     r.hourly.temperature_2m[hi],
          wind_speed_10m:     r.hourly.wind_speed_10m[hi],
          wind_direction_10m: r.hourly.wind_direction_10m[hi],
          surface_pressure:   r.hourly.surface_pressure[hi],
          precipitation:      r.hourly.precipitation[hi],
          cloud_cover:        r.hourly.cloud_cover[hi],
        };
        data.fish_score = computeFishScore(data);
        cachePut(points[i].lat, points[i].lon, data);
        return { lat: points[i].lat, lon: points[i].lon, data };
      });
    }

    // --- Render ---
    function renderOverlay(dataPoints, step) {
      rectLayer.clearLayers();
      labelLayer.clearLayers();

      const colorBy = document.getElementById('colorBy').value;
      const opacity = parseFloat(document.getElementById('opacity').value);
      const fontSize = parseInt(document.getElementById('fontSize').value);
      const scale = COLOR_SCALES[colorBy];
      const halfCell = step / 2;
      const zoom = map.getZoom();

      for (const pt of dataPoints) {
        const d = pt.data;
        if (!d) continue;

        // Colored rectangle
        const colorVal = d[colorBy];
        if (colorVal === null || colorVal === undefined) continue;
        const color = getColor(colorVal, scale.stops);

        const rect = L.rectangle(
          [[pt.lat - halfCell, pt.lon - halfCell], [pt.lat + halfCell, pt.lon + halfCell]],
          { color: 'transparent', weight: 0, fillColor: rgbStr(color, 1), fillOpacity: opacity }
        );
        rectLayer.addLayer(rect);

        // Build label HTML
        const arrow = windDirToArrow(d.wind_direction_10m);
        const compass = windDirToCompass(d.wind_direction_10m);

        let labelHtml;
        if (zoom >= 10) {
          // Detailed view
          labelHtml = `<div class="tile-label" style="font-size:${fontSize}px">` +
            `${d.temperature_2m.toFixed(1)}° ` +
            `<span class="wind-arrow">${arrow}</span>${d.wind_speed_10m.toFixed(0)}` +
            `<br>${d.surface_pressure.toFixed(0)}hPa ${d.precipitation.toFixed(1)}mm` +
            `<br>☁${d.cloud_cover}%` +
            `</div>`;
        } else if (zoom >= 8) {
          // Medium view
          labelHtml = `<div class="tile-label" style="font-size:${fontSize}px">` +
            `${d.temperature_2m.toFixed(0)}° ` +
            `<span class="wind-arrow">${arrow}</span>${d.wind_speed_10m.toFixed(0)}` +
            `<br>${d.surface_pressure.toFixed(0)}hPa` +
            `</div>`;
        } else {
          // Minimal view
          labelHtml = `<div class="tile-label" style="font-size:${fontSize}px">` +
            `${d.temperature_2m.toFixed(0)}° ` +
            `<span class="wind-arrow">${arrow}</span>` +
            `</div>`;
        }

        const icon = L.divIcon({
          html: labelHtml,
          className: '',
          iconSize: null,
          iconAnchor: [0, 0],
        });
        const marker = L.marker([pt.lat, pt.lon], {
          icon,
          interactive: true,
          keyboard: false,
        });

        // Popup with full details (fishing score shown here only)
        const scoreClass = d.fish_score >= 65 ? 'fish-score-good'
          : d.fish_score >= 40 ? 'fish-score-ok' : 'fish-score-poor';
        marker.bindPopup(
          `<b>Fishing Score: <span class="${scoreClass}">${d.fish_score}/100</span></b><br>` +
          `<b>Temp:</b> ${d.temperature_2m.toFixed(1)} °C<br>` +
          `<b>Wind:</b> ${d.wind_speed_10m.toFixed(1)} km/h ${compass} (${d.wind_direction_10m}°) ${arrow}<br>` +
          `<b>Pressure:</b> ${d.surface_pressure.toFixed(1)} hPa<br>` +
          `<b>Rain:</b> ${d.precipitation.toFixed(1)} mm<br>` +
          `<b>Cloud:</b> ${d.cloud_cover}%<br>` +
          `<small>(${pt.lat.toFixed(3)}, ${pt.lon.toFixed(3)})</small>`
        );
        labelLayer.addLayer(marker);
      }
    }

    // --- Main loader ---
    async function loadWeatherData(forceRefresh = false) {
      if (currentAbort) currentAbort.abort();
      const ac = new AbortController();
      currentAbort = ac;

      const zoom = map.getZoom();
      const bounds = map.getBounds();
      const step = getGridStep(zoom);
      const points = buildGrid(bounds, step);
      const statusEl = document.getElementById('status');

      // Split cached vs uncached
      const cached = [], uncached = [];
      for (const pt of points) {
        const d = forceRefresh ? undefined : cacheGet(pt.lat, pt.lon);
        if (d !== undefined) {
          cached.push({ lat: pt.lat, lon: pt.lon, data: d });
        } else {
          uncached.push(pt);
        }
      }

      statusEl.textContent = `${cached.length} cached, ${uncached.length} to fetch...`;

      // Render cached immediately
      if (uncached.length === 0) {
        lastRenderData = { points: cached, step };
        renderOverlay(cached, step);
        updateLegend();
        statusEl.textContent = `${cached.length} pts (all cached) | z${zoom} ~${(step * 111).toFixed(0)}km | cache: ${cacheValidCount()}`;
        return;
      }

      if (cached.length > 0) renderOverlay(cached, step);
      else { rectLayer.clearLayers(); labelLayer.clearLayers(); }

      try {
        const batches = [];
        for (let i = 0; i < uncached.length; i += MAX_POINTS_PER_REQUEST) {
          batches.push(uncached.slice(i, i + MAX_POINTS_PER_REQUEST));
        }

        const all = [...cached];
        for (let i = 0; i < batches.length; i++) {
          if (ac.signal.aborted) return;
          statusEl.textContent = `Batch ${i + 1}/${batches.length} (${uncached.length} new, ${cached.length} cached)...`;
          const results = await fetchBatch(batches[i], ac.signal);
          all.push(...results);
          if (!ac.signal.aborted) renderOverlay(all, step);
          if (i < batches.length - 1) await sleep(BATCH_DELAY_MS);
        }

        if (ac.signal.aborted) return;
        lastRenderData = { points: all, step };
        renderOverlay(all, step);
        updateLegend();
        statusEl.textContent = `${all.length} pts (${cached.length} cached + ${uncached.length} new) | z${zoom} ~${(step * 111).toFixed(0)}km | cache: ${cacheValidCount()}`;
      } catch (err) {
        if (err.name === 'AbortError') return;
        console.error(err);
        statusEl.textContent = `Error: ${err.message}`;
      }
    }

    function updateLegend() {
      const colorBy = document.getElementById('colorBy').value;
      const scale = COLOR_SCALES[colorBy];
      const el = document.getElementById('legendScale');

      let html = `<div class="panel-section-title">${scale.label} ${scale.unit ? '(' + scale.unit + ')' : ''}</div>`;
      for (const s of scale.stops) {
        html += `<div class="legend-row">
          <div class="legend-color" style="background:rgb(${s.color.join(',')})"></div>
          ${s.val}${scale.unit ? ' ' + scale.unit : ''}
        </div>`;
      }
      el.innerHTML = html;
    }

    // --- Side panel toggle ---
    const panel = document.getElementById('sidePanel');
    const backdrop = document.getElementById('panelBackdrop');
    const toggleBtn = document.getElementById('panelToggle');
    const closeBtn = document.getElementById('panelClose');

    function openPanel() {
      panel.classList.add('open');
      backdrop.classList.add('visible');
      toggleBtn.style.display = 'none';
    }
    function closePanel() {
      panel.classList.remove('open');
      backdrop.classList.remove('visible');
      toggleBtn.style.display = '';
    }

    toggleBtn.addEventListener('click', openPanel);
    closeBtn.addEventListener('click', closePanel);
    backdrop.addEventListener('click', closePanel);

    // --- Events ---
    function debouncedLoad() {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => loadWeatherData(false), 800);
    }

    map.on('moveend', debouncedLoad);
    map.on('zoomend', debouncedLoad);

    document.getElementById('colorBy').addEventListener('change', () => {
      if (lastRenderData) {
        renderOverlay(lastRenderData.points, lastRenderData.step);
        updateLegend();
      }
    });

    document.getElementById('opacity').addEventListener('input', () => {
      if (lastRenderData) renderOverlay(lastRenderData.points, lastRenderData.step);
    });

    document.getElementById('fontSize').addEventListener('input', () => {
      if (lastRenderData) renderOverlay(lastRenderData.points, lastRenderData.step);
    });

    document.getElementById('refresh').addEventListener('click', () => loadWeatherData(true));

    updateLegend();
    setTimeout(() => loadWeatherData(false), 500);
  </script>
</body>
</html>
