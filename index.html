<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bulgaria Weather Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    #map { width: 100%; height: 100vh; }

    .controls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1000;
      background: white;
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      font-size: 13px;
      max-width: 220px;
    }
    .controls label {
      display: block;
      margin-bottom: 6px;
      font-weight: 600;
    }
    .controls select {
      width: 100%;
      padding: 4px 6px;
      margin-bottom: 10px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }
    .controls button {
      width: 100%;
      padding: 6px;
      border: none;
      border-radius: 4px;
      background: #2563eb;
      color: white;
      cursor: pointer;
      font-weight: 600;
    }
    .controls button:hover { background: #1d4ed8; }
    .controls button:disabled { background: #93c5fd; cursor: wait; }

    .legend {
      position: absolute;
      bottom: 30px;
      right: 10px;
      z-index: 1000;
      background: white;
      border-radius: 8px;
      padding: 10px 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      font-size: 12px;
    }
    .legend-title { font-weight: 600; margin-bottom: 6px; }
    .legend-row { display: flex; align-items: center; margin: 2px 0; }
    .legend-color {
      width: 20px;
      height: 14px;
      margin-right: 6px;
      border-radius: 2px;
      border: 1px solid rgba(0,0,0,0.1);
    }

    .status {
      position: absolute;
      bottom: 30px;
      left: 10px;
      z-index: 1000;
      background: white;
      border-radius: 8px;
      padding: 8px 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="controls">
    <label for="variable">Weather Variable</label>
    <select id="variable">
      <option value="temperature_2m">Temperature (°C)</option>
      <option value="relative_humidity_2m">Humidity (%)</option>
      <option value="wind_speed_10m">Wind Speed (km/h)</option>
      <option value="precipitation">Precipitation (mm)</option>
      <option value="cloud_cover">Cloud Cover (%)</option>
    </select>
    <label for="opacity">Opacity</label>
    <input type="range" id="opacity" min="0.1" max="0.9" step="0.05" value="0.45" style="width:100%;margin-bottom:10px;">
    <button id="refresh">Refresh Data</button>
  </div>

  <div class="legend" id="legend"></div>
  <div class="status" id="status">Zoom or pan to load weather data</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // --- Config ---
    const BULGARIA_CENTER = [42.7, 25.5];
    const INITIAL_ZOOM = 8;
    const API_BASE = 'https://api.open-meteo.com/v1/forecast';
    const MAX_POINTS_PER_REQUEST = 200; // smaller batches to avoid 429s
    const CACHE_TTL_MS = 30 * 60 * 1000; // 30 min cache lifetime
    const CACHE_MAX_ENTRIES = 5000; // max individual point entries in cache
    const BATCH_DELAY_MS = 300; // delay between sequential API batches
    const MAX_RETRIES = 3;

    // Variable metadata: color scales and units
    const VARIABLES = {
      temperature_2m: {
        unit: '°C',
        stops: [
          { val: -15, color: [63, 0, 125] },
          { val: -5,  color: [49, 54, 149] },
          { val: 0,   color: [69, 117, 180] },
          { val: 5,   color: [116, 173, 209] },
          { val: 10,  color: [171, 217, 233] },
          { val: 15,  color: [224, 243, 248] },
          { val: 20,  color: [255, 255, 191] },
          { val: 25,  color: [254, 224, 144] },
          { val: 30,  color: [253, 174, 97] },
          { val: 35,  color: [244, 109, 67] },
          { val: 40,  color: [215, 48, 39] },
          { val: 45,  color: [165, 0, 38] },
        ]
      },
      relative_humidity_2m: {
        unit: '%',
        stops: [
          { val: 0,   color: [255, 255, 178] },
          { val: 20,  color: [254, 204, 92] },
          { val: 40,  color: [253, 141, 60] },
          { val: 60,  color: [227, 26, 28] },
          { val: 80,  color: [49, 54, 149] },
          { val: 100, color: [8, 29, 88] },
        ]
      },
      wind_speed_10m: {
        unit: 'km/h',
        stops: [
          { val: 0,   color: [255, 255, 255] },
          { val: 5,   color: [200, 230, 255] },
          { val: 15,  color: [100, 180, 255] },
          { val: 30,  color: [30, 100, 200] },
          { val: 50,  color: [200, 80, 80] },
          { val: 80,  color: [150, 0, 0] },
        ]
      },
      precipitation: {
        unit: 'mm',
        stops: [
          { val: 0,   color: [255, 255, 255] },
          { val: 0.5, color: [200, 230, 255] },
          { val: 2,   color: [100, 180, 255] },
          { val: 5,   color: [30, 100, 220] },
          { val: 15,  color: [20, 50, 150] },
          { val: 30,  color: [100, 0, 150] },
        ]
      },
      cloud_cover: {
        unit: '%',
        stops: [
          { val: 0,   color: [255, 255, 220] },
          { val: 25,  color: [220, 220, 200] },
          { val: 50,  color: [180, 180, 180] },
          { val: 75,  color: [130, 130, 140] },
          { val: 100, color: [80, 80, 100] },
        ]
      },
    };

    // --- Cache ---
    // Key: "variable|lat|lon" -> { value, timestamp }
    const cache = new Map();

    function cacheKey(variable, lat, lon) {
      return `${variable}|${lat}|${lon}`;
    }

    function cacheGet(variable, lat, lon) {
      const key = cacheKey(variable, lat, lon);
      const entry = cache.get(key);
      if (!entry) return undefined;
      if (Date.now() - entry.timestamp > CACHE_TTL_MS) {
        cache.delete(key);
        return undefined;
      }
      return entry.value;
    }

    function cachePut(variable, lat, lon, value) {
      // Evict oldest entries if cache is too large
      if (cache.size >= CACHE_MAX_ENTRIES) {
        let oldest = null, oldestKey = null;
        for (const [k, v] of cache) {
          if (!oldest || v.timestamp < oldest) { oldest = v.timestamp; oldestKey = k; }
        }
        if (oldestKey) cache.delete(oldestKey);
      }
      cache.set(cacheKey(variable, lat, lon), { value, timestamp: Date.now() });
    }

    function cacheStats() {
      let valid = 0;
      const now = Date.now();
      for (const v of cache.values()) {
        if (now - v.timestamp <= CACHE_TTL_MS) valid++;
      }
      return { total: cache.size, valid };
    }

    // --- Map setup ---
    const map = L.map('map', {
      center: BULGARIA_CENTER,
      zoom: INITIAL_ZOOM,
      minZoom: 6,
      maxZoom: 13,
    });

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors | Weather: <a href="https://open-meteo.com/">Open-Meteo</a>',
      maxZoom: 19,
    }).addTo(map);

    // --- State ---
    let weatherLayer = L.layerGroup().addTo(map);
    let currentAbort = null;
    let debounceTimer = null;
    // Store last rendered data so opacity changes don't need a refetch
    let lastRenderData = null;

    // --- Helpers ---

    function getColor(value, stops) {
      if (value <= stops[0].val) return stops[0].color;
      if (value >= stops[stops.length - 1].val) return stops[stops.length - 1].color;
      for (let i = 0; i < stops.length - 1; i++) {
        if (value >= stops[i].val && value <= stops[i + 1].val) {
          const t = (value - stops[i].val) / (stops[i + 1].val - stops[i].val);
          return [
            Math.round(stops[i].color[0] + t * (stops[i + 1].color[0] - stops[i].color[0])),
            Math.round(stops[i].color[1] + t * (stops[i + 1].color[1] - stops[i].color[1])),
            Math.round(stops[i].color[2] + t * (stops[i + 1].color[2] - stops[i].color[2])),
          ];
        }
      }
      return stops[stops.length - 1].color;
    }

    function rgbStr(c, a) { return `rgba(${c[0]},${c[1]},${c[2]},${a})`; }

    // Grid step in degrees based on zoom level (coarser to reduce requests)
    function getGridStep(zoom) {
      if (zoom >= 12) return 0.03;  // ~3 km
      if (zoom >= 11) return 0.06;  // ~6 km
      if (zoom >= 10) return 0.1;   // ~10 km
      if (zoom >= 9)  return 0.15;  // ~15 km
      if (zoom >= 8)  return 0.2;   // ~20 km
      if (zoom >= 7)  return 0.35;  // ~35 km
      return 0.5;                    // ~50 km
    }

    function buildGrid(bounds, step) {
      const points = [];
      const south = Math.floor(bounds.getSouth() / step) * step;
      const north = Math.ceil(bounds.getNorth() / step) * step;
      const west = Math.floor(bounds.getWest() / step) * step;
      const east = Math.ceil(bounds.getEast() / step) * step;

      for (let lat = south; lat <= north; lat += step) {
        for (let lon = west; lon <= east; lon += step) {
          points.push({ lat: Math.round(lat * 1000) / 1000, lon: Math.round(lon * 1000) / 1000 });
        }
      }
      return points;
    }

    function getCurrentHourIndex(times) {
      const now = new Date();
      let bestIdx = 0;
      let bestDiff = Infinity;
      for (let i = 0; i < times.length; i++) {
        const diff = Math.abs(new Date(times[i]).getTime() - now.getTime());
        if (diff < bestDiff) { bestDiff = diff; bestIdx = i; }
      }
      return bestIdx;
    }

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    // Fetch with retry + exponential backoff for 429s
    async function fetchWithRetry(url, signal) {
      for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
        const resp = await fetch(url, { signal });
        if (resp.ok) return resp;
        if (resp.status === 429 && attempt < MAX_RETRIES) {
          const retryAfter = resp.headers.get('Retry-After');
          const waitMs = retryAfter
            ? parseInt(retryAfter, 10) * 1000
            : Math.min(2000 * Math.pow(2, attempt), 16000);
          console.warn(`429 rate-limited, retrying in ${waitMs}ms (attempt ${attempt + 1}/${MAX_RETRIES})`);
          await sleep(waitMs);
          continue;
        }
        throw new Error(`API error: ${resp.status}`);
      }
      throw new Error('Max retries exceeded (429)');
    }

    // Fetch weather for a batch of points (only those not cached)
    async function fetchBatch(points, variable, signal) {
      const lats = points.map(p => p.lat).join(',');
      const lons = points.map(p => p.lon).join(',');
      const url = `${API_BASE}?latitude=${lats}&longitude=${lons}&hourly=${variable}&forecast_days=1&timezone=auto`;

      const resp = await fetchWithRetry(url, signal);
      const data = await resp.json();

      const results = Array.isArray(data) ? data : [data];
      return results.map((r, i) => {
        const hourIdx = getCurrentHourIndex(r.hourly.time);
        const value = r.hourly[variable][hourIdx];
        // Store in cache
        cachePut(variable, points[i].lat, points[i].lon, value);
        return {
          lat: points[i].lat,
          lon: points[i].lon,
          value,
        };
      });
    }

    // Render data points onto the map (no fetching)
    function renderOverlay(dataPoints, variable, step) {
      weatherLayer.clearLayers();
      const varMeta = VARIABLES[variable];
      const opacity = parseFloat(document.getElementById('opacity').value);
      const halfCell = step / 2;

      for (const pt of dataPoints) {
        if (pt.value === null || pt.value === undefined) continue;
        const color = getColor(pt.value, varMeta.stops);
        const rect = L.rectangle(
          [[pt.lat - halfCell, pt.lon - halfCell], [pt.lat + halfCell, pt.lon + halfCell]],
          {
            color: rgbStr(color, opacity + 0.15),
            weight: 0,
            fillColor: rgbStr(color, 1),
            fillOpacity: opacity,
          }
        );
        rect.bindPopup(`<b>${variable.replace(/_/g, ' ')}</b><br>
          ${pt.value.toFixed(1)} ${varMeta.unit}<br>
          <small>(${pt.lat.toFixed(3)}, ${pt.lon.toFixed(3)})</small>`);
        weatherLayer.addLayer(rect);
      }
    }

    // Main data loading function
    async function loadWeatherData(forceRefresh = false) {
      if (currentAbort) currentAbort.abort();
      const abortController = new AbortController();
      currentAbort = abortController;

      const variable = document.getElementById('variable').value;
      const zoom = map.getZoom();
      const bounds = map.getBounds();
      const step = getGridStep(zoom);
      const points = buildGrid(bounds, step);

      const statusEl = document.getElementById('status');

      // Split points into cached vs uncached
      const cachedResults = [];
      const uncachedPoints = [];
      for (const pt of points) {
        const val = forceRefresh ? undefined : cacheGet(variable, pt.lat, pt.lon);
        if (val !== undefined) {
          cachedResults.push({ lat: pt.lat, lon: pt.lon, value: val });
        } else {
          uncachedPoints.push(pt);
        }
      }

      const stats = cacheStats();
      statusEl.textContent = `${cachedResults.length} cached, ${uncachedPoints.length} to fetch (cache: ${stats.valid} entries)`;

      // If everything is cached, just render
      if (uncachedPoints.length === 0) {
        lastRenderData = { points: cachedResults, variable, step };
        renderOverlay(cachedResults, variable, step);
        updateLegend(variable);
        statusEl.textContent = `Showing ${cachedResults.length} points (all from cache) | Zoom: ${zoom} | Grid: ~${(step * 111).toFixed(0)} km`;
        return;
      }

      // Render cached data immediately so the user sees something
      if (cachedResults.length > 0) {
        renderOverlay(cachedResults, variable, step);
      } else {
        weatherLayer.clearLayers();
      }

      try {
        // Batch uncached points
        const batches = [];
        for (let i = 0; i < uncachedPoints.length; i += MAX_POINTS_PER_REQUEST) {
          batches.push(uncachedPoints.slice(i, i + MAX_POINTS_PER_REQUEST));
        }

        const allResults = [...cachedResults];
        for (let i = 0; i < batches.length; i++) {
          if (abortController.signal.aborted) return;
          statusEl.textContent = `Fetching batch ${i + 1}/${batches.length} (${uncachedPoints.length} new points, ${cachedResults.length} cached)...`;
          const results = await fetchBatch(batches[i], variable, abortController.signal);
          allResults.push(...results);

          // Progressive render: update map after each batch
          if (!abortController.signal.aborted) {
            renderOverlay(allResults, variable, step);
          }

          // Delay between batches to avoid hammering the API
          if (i < batches.length - 1) {
            await sleep(BATCH_DELAY_MS);
          }
        }

        if (abortController.signal.aborted) return;

        lastRenderData = { points: allResults, variable, step };
        renderOverlay(allResults, variable, step);
        updateLegend(variable);
        const s = cacheStats();
        statusEl.textContent = `Showing ${allResults.length} points (${cachedResults.length} cached, ${uncachedPoints.length} fetched) | Zoom: ${zoom} | Grid: ~${(step * 111).toFixed(0)} km | Cache: ${s.valid}`;
      } catch (err) {
        if (err.name === 'AbortError') return;
        console.error(err);
        statusEl.textContent = `Error: ${err.message}`;
      }
    }

    function updateLegend(variable) {
      const meta = VARIABLES[variable];
      const legendEl = document.getElementById('legend');
      let html = `<div class="legend-title">${variable.replace(/_/g, ' ')} (${meta.unit})</div>`;
      for (const stop of meta.stops) {
        const c = stop.color;
        html += `<div class="legend-row">
          <div class="legend-color" style="background:rgb(${c[0]},${c[1]},${c[2]})"></div>
          ${stop.val} ${meta.unit}
        </div>`;
      }
      legendEl.innerHTML = html;
    }

    // --- Event listeners ---
    function debouncedLoad() {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => loadWeatherData(false), 800);
    }

    map.on('moveend', debouncedLoad);
    map.on('zoomend', debouncedLoad);

    document.getElementById('variable').addEventListener('change', () => loadWeatherData(false));

    // Opacity slider: re-render from lastRenderData without any fetch
    document.getElementById('opacity').addEventListener('input', () => {
      if (lastRenderData) {
        renderOverlay(lastRenderData.points, lastRenderData.variable, lastRenderData.step);
      }
    });

    // Refresh button forces cache bypass
    document.getElementById('refresh').addEventListener('click', () => loadWeatherData(true));

    // Initial legend
    updateLegend('temperature_2m');

    // Load data after a short delay to let map settle
    setTimeout(() => loadWeatherData(false), 500);
  </script>
</body>
</html>
