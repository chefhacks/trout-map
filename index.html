<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Bulgaria Weather Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    #map { width: 100%; height: 100vh; }

    .controls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1000;
      background: white;
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      font-size: 13px;
      max-width: 220px;
    }
    .controls label {
      display: block;
      margin-bottom: 6px;
      font-weight: 600;
    }
    .controls select {
      width: 100%;
      padding: 4px 6px;
      margin-bottom: 10px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }
    .controls button {
      width: 100%;
      padding: 6px;
      border: none;
      border-radius: 4px;
      background: #2563eb;
      color: white;
      cursor: pointer;
      font-weight: 600;
    }
    .controls button:hover { background: #1d4ed8; }
    .controls button:disabled { background: #93c5fd; cursor: wait; }

    .legend {
      position: absolute;
      bottom: 30px;
      right: 10px;
      z-index: 1000;
      background: white;
      border-radius: 8px;
      padding: 10px 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      font-size: 12px;
    }
    .legend-title { font-weight: 600; margin-bottom: 6px; }
    .legend-row { display: flex; align-items: center; margin: 2px 0; }
    .legend-color {
      width: 20px;
      height: 14px;
      margin-right: 6px;
      border-radius: 2px;
      border: 1px solid rgba(0,0,0,0.1);
    }

    .status {
      position: absolute;
      bottom: 30px;
      left: 10px;
      z-index: 1000;
      background: white;
      border-radius: 8px;
      padding: 8px 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="controls">
    <label for="variable">Weather Variable</label>
    <select id="variable">
      <option value="temperature_2m">Temperature (°C)</option>
      <option value="relative_humidity_2m">Humidity (%)</option>
      <option value="wind_speed_10m">Wind Speed (km/h)</option>
      <option value="precipitation">Precipitation (mm)</option>
      <option value="cloud_cover">Cloud Cover (%)</option>
    </select>
    <label for="opacity">Opacity</label>
    <input type="range" id="opacity" min="0.1" max="0.9" step="0.05" value="0.45" style="width:100%;margin-bottom:10px;">
    <button id="refresh">Refresh Data</button>
  </div>

  <div class="legend" id="legend"></div>
  <div class="status" id="status">Zoom or pan to load weather data</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // --- Config ---
    const BULGARIA_CENTER = [42.7, 25.5];
    const INITIAL_ZOOM = 8;
    const API_BASE = 'https://api.open-meteo.com/v1/forecast';
    const MAX_POINTS_PER_REQUEST = 800;

    // Variable metadata: color scales and units
    const VARIABLES = {
      temperature_2m: {
        unit: '°C',
        stops: [
          { val: -15, color: [63, 0, 125] },
          { val: -5,  color: [49, 54, 149] },
          { val: 0,   color: [69, 117, 180] },
          { val: 5,   color: [116, 173, 209] },
          { val: 10,  color: [171, 217, 233] },
          { val: 15,  color: [224, 243, 248] },
          { val: 20,  color: [255, 255, 191] },
          { val: 25,  color: [254, 224, 144] },
          { val: 30,  color: [253, 174, 97] },
          { val: 35,  color: [244, 109, 67] },
          { val: 40,  color: [215, 48, 39] },
          { val: 45,  color: [165, 0, 38] },
        ]
      },
      relative_humidity_2m: {
        unit: '%',
        stops: [
          { val: 0,   color: [255, 255, 178] },
          { val: 20,  color: [254, 204, 92] },
          { val: 40,  color: [253, 141, 60] },
          { val: 60,  color: [227, 26, 28] },
          { val: 80,  color: [49, 54, 149] },
          { val: 100, color: [8, 29, 88] },
        ]
      },
      wind_speed_10m: {
        unit: 'km/h',
        stops: [
          { val: 0,   color: [255, 255, 255] },
          { val: 5,   color: [200, 230, 255] },
          { val: 15,  color: [100, 180, 255] },
          { val: 30,  color: [30, 100, 200] },
          { val: 50,  color: [200, 80, 80] },
          { val: 80,  color: [150, 0, 0] },
        ]
      },
      precipitation: {
        unit: 'mm',
        stops: [
          { val: 0,   color: [255, 255, 255] },
          { val: 0.5, color: [200, 230, 255] },
          { val: 2,   color: [100, 180, 255] },
          { val: 5,   color: [30, 100, 220] },
          { val: 15,  color: [20, 50, 150] },
          { val: 30,  color: [100, 0, 150] },
        ]
      },
      cloud_cover: {
        unit: '%',
        stops: [
          { val: 0,   color: [255, 255, 220] },
          { val: 25,  color: [220, 220, 200] },
          { val: 50,  color: [180, 180, 180] },
          { val: 75,  color: [130, 130, 140] },
          { val: 100, color: [80, 80, 100] },
        ]
      },
    };

    // --- Map setup ---
    const map = L.map('map', {
      center: BULGARIA_CENTER,
      zoom: INITIAL_ZOOM,
      minZoom: 6,
      maxZoom: 13,
    });

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors | Weather: <a href="https://open-meteo.com/">Open-Meteo</a>',
      maxZoom: 19,
    }).addTo(map);

    // --- State ---
    let weatherLayer = L.layerGroup().addTo(map);
    let currentAbort = null;
    let debounceTimer = null;

    // --- Helpers ---

    // Interpolate color from stops
    function getColor(value, stops) {
      if (value <= stops[0].val) return stops[0].color;
      if (value >= stops[stops.length - 1].val) return stops[stops.length - 1].color;
      for (let i = 0; i < stops.length - 1; i++) {
        if (value >= stops[i].val && value <= stops[i + 1].val) {
          const t = (value - stops[i].val) / (stops[i + 1].val - stops[i].val);
          return [
            Math.round(stops[i].color[0] + t * (stops[i + 1].color[0] - stops[i].color[0])),
            Math.round(stops[i].color[1] + t * (stops[i + 1].color[1] - stops[i].color[1])),
            Math.round(stops[i].color[2] + t * (stops[i + 1].color[2] - stops[i].color[2])),
          ];
        }
      }
      return stops[stops.length - 1].color;
    }

    function rgbStr(c, a) { return `rgba(${c[0]},${c[1]},${c[2]},${a})`; }

    // Grid step in degrees based on zoom level
    // Zoomed out = coarser grid, zoomed in = finer grid
    function getGridStep(zoom) {
      if (zoom >= 12) return 0.02;  // ~2 km
      if (zoom >= 11) return 0.04;  // ~4 km
      if (zoom >= 10) return 0.06;  // ~6 km
      if (zoom >= 9)  return 0.1;   // ~10 km
      if (zoom >= 8)  return 0.15;  // ~15 km
      if (zoom >= 7)  return 0.25;  // ~25 km
      return 0.4;                    // ~40 km
    }

    // Build grid of coordinates within current map bounds
    function buildGrid(bounds, step) {
      const points = [];
      const south = Math.floor(bounds.getSouth() / step) * step;
      const north = Math.ceil(bounds.getNorth() / step) * step;
      const west = Math.floor(bounds.getWest() / step) * step;
      const east = Math.ceil(bounds.getEast() / step) * step;

      for (let lat = south; lat <= north; lat += step) {
        for (let lon = west; lon <= east; lon += step) {
          points.push({ lat: Math.round(lat * 1000) / 1000, lon: Math.round(lon * 1000) / 1000 });
        }
      }
      return points;
    }

    // Find the current hour's index in an hourly time array
    function getCurrentHourIndex(times) {
      const now = new Date();
      const nowISO = now.toISOString().slice(0, 13); // "YYYY-MM-DDTHH"
      let bestIdx = 0;
      let bestDiff = Infinity;
      for (let i = 0; i < times.length; i++) {
        const diff = Math.abs(new Date(times[i]).getTime() - now.getTime());
        if (diff < bestDiff) { bestDiff = diff; bestIdx = i; }
      }
      return bestIdx;
    }

    // Fetch weather for a batch of points
    async function fetchBatch(points, variable, signal) {
      const lats = points.map(p => p.lat).join(',');
      const lons = points.map(p => p.lon).join(',');
      const url = `${API_BASE}?latitude=${lats}&longitude=${lons}&hourly=${variable}&forecast_days=1&timezone=auto`;

      const resp = await fetch(url, { signal });
      if (!resp.ok) throw new Error(`API error: ${resp.status}`);
      const data = await resp.json();

      // API returns array for multiple points, single object for one point
      const results = Array.isArray(data) ? data : [data];
      return results.map((r, i) => {
        const hourIdx = getCurrentHourIndex(r.hourly.time);
        return {
          lat: points[i].lat,
          lon: points[i].lon,
          value: r.hourly[variable][hourIdx],
        };
      });
    }

    // Main data loading function
    async function loadWeatherData() {
      if (currentAbort) currentAbort.abort();
      const abortController = new AbortController();
      currentAbort = abortController;

      const variable = document.getElementById('variable').value;
      const zoom = map.getZoom();
      const bounds = map.getBounds();
      const step = getGridStep(zoom);
      const points = buildGrid(bounds, step);

      const statusEl = document.getElementById('status');
      statusEl.textContent = `Loading ${points.length} grid points...`;

      weatherLayer.clearLayers();

      try {
        // Split into batches of MAX_POINTS_PER_REQUEST
        const batches = [];
        for (let i = 0; i < points.length; i += MAX_POINTS_PER_REQUEST) {
          batches.push(points.slice(i, i + MAX_POINTS_PER_REQUEST));
        }

        const allResults = [];
        for (let i = 0; i < batches.length; i++) {
          if (abortController.signal.aborted) return;
          statusEl.textContent = `Loading batch ${i + 1}/${batches.length} (${points.length} points)...`;
          const results = await fetchBatch(batches[i], variable, abortController.signal);
          allResults.push(...results);
        }

        if (abortController.signal.aborted) return;

        // Draw overlay
        const varMeta = VARIABLES[variable];
        const opacity = parseFloat(document.getElementById('opacity').value);
        const cellSize = step; // degrees

        for (const pt of allResults) {
          if (pt.value === null || pt.value === undefined) continue;
          const color = getColor(pt.value, varMeta.stops);
          const halfCell = cellSize / 2;
          const rect = L.rectangle(
            [[pt.lat - halfCell, pt.lon - halfCell], [pt.lat + halfCell, pt.lon + halfCell]],
            {
              color: rgbStr(color, opacity + 0.15),
              weight: 0,
              fillColor: rgbStr(color, 1),
              fillOpacity: opacity,
            }
          );
          rect.bindPopup(`<b>${variable.replace(/_/g, ' ')}</b><br>
            ${pt.value.toFixed(1)} ${varMeta.unit}<br>
            <small>(${pt.lat.toFixed(3)}, ${pt.lon.toFixed(3)})</small>`);
          weatherLayer.addLayer(rect);
        }

        updateLegend(variable);
        statusEl.textContent = `Showing ${allResults.length} points | Zoom: ${zoom} | Grid: ~${(step * 111).toFixed(0)} km`;
      } catch (err) {
        if (err.name === 'AbortError') return;
        console.error(err);
        statusEl.textContent = `Error: ${err.message}`;
      }
    }

    function updateLegend(variable) {
      const meta = VARIABLES[variable];
      const legendEl = document.getElementById('legend');
      let html = `<div class="legend-title">${variable.replace(/_/g, ' ')} (${meta.unit})</div>`;
      for (const stop of meta.stops) {
        const c = stop.color;
        html += `<div class="legend-row">
          <div class="legend-color" style="background:rgb(${c[0]},${c[1]},${c[2]})"></div>
          ${stop.val} ${meta.unit}
        </div>`;
      }
      legendEl.innerHTML = html;
    }

    // --- Event listeners ---
    function debouncedLoad() {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(loadWeatherData, 600);
    }

    map.on('moveend', debouncedLoad);
    map.on('zoomend', debouncedLoad);

    document.getElementById('variable').addEventListener('change', loadWeatherData);
    document.getElementById('opacity').addEventListener('input', () => {
      // Re-render with new opacity without refetching
      loadWeatherData();
    });
    document.getElementById('refresh').addEventListener('click', loadWeatherData);

    // Initial legend
    updateLegend('temperature_2m');

    // Load data after a short delay to let map settle
    setTimeout(loadWeatherData, 500);
  </script>
</body>
</html>
